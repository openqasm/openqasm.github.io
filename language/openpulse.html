
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>OpenPulse Grammar &#8212; OpenQASM Live Specification  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/colors.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="OpenQasm 3.0 Grammar" href="../grammar/index.html" />
    <link rel="prev" title="Pulse-level descriptions of gates and measurement" href="pulses.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="openpulse-grammar">
<h1>OpenPulse Grammar<a class="headerlink" href="#openpulse-grammar" title="Permalink to this heading">¶</a></h1>
<p><em>The OpenPulse grammar is still in active development and is liable to change. If you are working on an implementation and find this specification unclear or not supporting your use-cases, please join our community effort to improve pulse-level support in OpenQasm.</em></p>
<p>OpenQASM allows users to provide the target system’s implementation of quantum operations
with <code class="docutils literal notranslate"><span class="pre">cal</span></code> and <code class="docutils literal notranslate"><span class="pre">defcal</span></code> blocks . Calibration grammars are open to extension for system implementors. In
this document, we outline one such grammar, OpenPulse, which may be selected within a supporting
compiler through the declaration <code class="docutils literal notranslate"><span class="pre">defcalgrammar</span> <span class="pre">&quot;openpulse&quot;;</span></code>.</p>
<p>This grammar is primarily motivated by the original OpenPulse specification, a JSON wire-format for
pulse-level quantum programs defined in the paper <a href="#id3"><span class="problematic" id="id4">`Qiskit Backend Specifications for OpenQASM
and OpenPulse Experiment`_</span></a><span id="id1">[<a class="reference internal" href="../index.html#id56" title="D.C. Mckay, and T. Alexander, L. Bello, M.J. Biercuk, L. Bishop, J. Chen, J.M. Chow, D.C. Antonio, D. Egger, S. Filipp, J. Gomez, M. Hush, A. Javadi-Abhari, D. Moreda, P. Nation, B. Paulovicks, E. Winston, C.J. Wood, J. Wootton, and J.M. Gambetta. Qiskit backend specifications for openqasm and openpulse experiments. Arxiv, 2018. arXiv:1809.03452v1.">MaTAB+18</a>]</span>, however, is also inspired directly or indirectly through
other <a href="#id5"><span class="problematic" id="id6">`efforts in the field`_</span></a><span id="id2">[<a class="reference internal" href="../index.html#id59" title="An experimental microarchitecture for a superconducting quantum processor | Proceedings of the 50th Annual IEEE/ACM International Symposium on Microarchitecture. https://dl.acm.org/doi/10.1145/3123939.3123952.">Exp</a>, <a class="reference internal" href="../index.html#id62" title="Quil-lang/quil. quil-lang, June 2021.">Qui21</a>, <a class="reference internal" href="../index.html#id58" title="DiCarloLab-Delft/PycQED_py3. DiCarlo Lab, May 2021.">DiC21</a>, <a class="reference internal" href="../index.html#id57" title="Thomas Alexander, Naoki Kanazawa, Daniel J. Egger, Lauren Capelluto, Christopher J. Wood, Ali Javadi-Abhari, and David C. McKay. Qiskit pulse: programming quantum computers through the cloud with pulses. Quantum Science and Technology, 5(4):044006, August 2020. doi:10.1088/2058-9565/aba404.">AKE+20</a>, <a class="reference internal" href="../index.html#id61" title="Thien Nguyen and Alexander McCaskey. Enabling Pulse-level Programming, Compilation, and Execution in XACC. arXiv:2003.11971 [physics, physics:quant-ph], March 2020. arXiv:2003.11971.">NM20</a>]</span>.</p>
<p>The textual format described here has several advantages over the original JSON format:</p>
<ul class="simple">
<li><p>Improved readability.</p></li>
<li><p>Pulse timing is based on instruction ordering and works with programs containing branching
control flow.</p></li>
<li><p>Reusable gate calibrations enable more succinct calibration descriptions.</p></li>
<li><p>Pulse definitions are declared as a calibration for individual circuit instructions attached to
physical qubits enabling the microcoding of gate level operations.</p></li>
<li><p>Richer ability to compose complex pulses through natural DSP-like operations.</p></li>
</ul>
<p>Openpulse provides a flexible programming model that should extend to many quantum control schemes
and hardware. At the core of the OpenPulse grammar are the concepts of <code class="docutils literal notranslate"><span class="pre">port</span></code>s, <code class="docutils literal notranslate"><span class="pre">waveform</span></code>s and, <code class="docutils literal notranslate"><span class="pre">frame</span></code>s.
A <code class="docutils literal notranslate"><span class="pre">port</span></code> is a software abstraction representing any input or output component controlling qubits. It allows
a hardware vendor to provide relevant actuation knobs they wish to expose to the user in order to manipulate and observe
qubits, while hiding the complexities of the device’s underlying hardware. A <code class="docutils literal notranslate"><span class="pre">waveform</span></code> is a time-dependent envelope
that can be used to emit signals on an output port or receive signals from an input port. A <code class="docutils literal notranslate"><span class="pre">frame</span></code> is also a software
abstraction that acts as both a (1) <em>clock</em> within the quantum program with its time being incremented on each usage and
(2) a stateful <a class="reference external" href="https://en.wikipedia.org/wiki/Carrier_wave">carrier signal</a> defined by a frequency and phase. As such,
when transmitting signals to the qubit, a <code class="docutils literal notranslate"><span class="pre">frame</span></code> determines time at which the <code class="docutils literal notranslate"><span class="pre">waveform</span></code> envelope is emitted, its
carrier frequency, and it’s phase offset (see <span class="xref std std-ref">Play</span>  section for more details). When capturing signals from a qubit,
at minimum a <code class="docutils literal notranslate"><span class="pre">frame</span></code> determines the time at which the signal is captured (see <span class="xref std std-ref">Capture</span> section
for more details).</p>
<p>Note that this proposal fully supports and specifies scheduling when resources map to the qubits specified within
the defcal. However, it is possible for pulse-level resources to manipulate qubits that are not specified in the
<code class="docutils literal notranslate"><span class="pre">defcal</span></code>’s signature. As a future extension the language may support conveying to the scheduling layer which
resources are acted upon by a <code class="docutils literal notranslate"><span class="pre">defcal</span></code>  such that the scheduler may faithfully schedule the target program to
hardware resources.</p>
<section id="ports">
<h2>Ports<a class="headerlink" href="#ports" title="Permalink to this heading">¶</a></h2>
<p>A port is a software abstraction representing any input or output component meant to manipulate and observe qubits. Ports
are ultimately mapped to some combination of hardware resources, and there are varying versions of
this mapping with differing granularity. For instance, a port may directly map to a digital-to-analog converter.
Alternatively, a port may map to a combination of a digital NCO, analog-to-digital converter, local oscillator, or amplifier.
A single port may even map to multiple transmit (or receive) hardware that must work in synchronicity.
Ultimately, it is simply a means by which a hardware vendor can provide relevant actuation knobs they wish to expose to the user
in order to manipulate and observe qubits. As such, the level of granularity of the mapping is up to the hardware vendor.</p>
<p>There is a many-to-many relationship between qubits and ports. One qubit may have multiple ports
connecting to it. Pulses on different ports would have different physical
interactions with that qubit and thereby control different operations. A port may also have many qubits. For instance,
a port could manipulate the coupling between two neighboring qubits, or
could even reference multiple qubits in a chain.</p>
<p>Ports are vendor-specific and device-specific. It is expected that vendors
of quantum hardware provide the appropriate port names and qubit mappings
as configuration information to end users. Each port may also have associated
static settings, such as local-oscillator frequencies, which do not vary
throughout program execution. Again it is expected that vendors of quantum
hardware provide a method for manipulating those static settings if appropriate.</p>
<p>Currently all ports are bidirectional, eg., transmit and receive or in and out. It is the responsibility
of the hardware target to limit the operations that may be applied to a given port.</p>
<p>A port is only used to specify the physical resource on which to play a pulse or from which
to capture data. The hardware can be accessed as OpenPulse <code class="docutils literal notranslate"><span class="pre">port</span></code>’s via <code class="docutils literal notranslate"><span class="pre">extern</span></code>
identifier that specifies an external linkage that will be resolved at compile-time via vendor
supplied translation units.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">drive_port0</span>
</pre></div>
</div>
<p>It is expected that a hardware vendor provide some documentation as to the associated
functionality of a port (e.g. <cite>drive_port0</cite> referse to the XY control line of a qubit 0).</p>
</section>
<section id="frames">
<h2>Frames<a class="headerlink" href="#frames" title="Permalink to this heading">¶</a></h2>
<p>When interacting with qubits, it is necessary to keep track of a frame of reference, akin to the rotating
frame of a Hamiltonian, throughout the execution of a program. Openpulse provides a software abstraction of
<code class="docutils literal notranslate"><span class="pre">frame</span></code> type which is responsible for tracking two properties:</p>
<ul class="simple">
<li><p>Tracking time appropriately so programs do not need to deal in absolute time or with the
bookkeeping of advancing time in a sequence of pulses.</p></li>
<li><p>Tracking accrued phase by producing a complex value given an input time (i.e. via the mathematical
relationship <span class="math notranslate nohighlight">\(e^{i\left(2\pi f t + \theta\right)}\)</span>,  where <cite>f</cite> is frequency and
<span class="math notranslate nohighlight">\(\theta\)</span> is the accrued phase). In this way,  a <code class="docutils literal notranslate"><span class="pre">frame</span></code> type behaves analogously to
a <a class="reference external" href="https://en.wikipedia.org/wiki/Numerically-controlled_oscillator">numerically-controlled oscillator (NCO)</a>).
One motivation for keeping track of accrued phase is to allow pulses to be defined in the rotating frame with the
effect being an equivalent application in the lab frame (i.e. with the carrier supplied by the <code class="docutils literal notranslate"><span class="pre">frame</span></code>).
Another motivation is to more naturally implement a “virtual Z-gate”, which does not require a physical pulse but
rather shifts the phase of all future pulses on that frame.</p></li>
</ul>
<p>The frame is composed of four parts:</p>
<ol class="arabic simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">port</span></code> to which it is attached. This can only be set upon initialization, and never changed subsequently.</p></li>
<li><p>A frequency <code class="docutils literal notranslate"><span class="pre">frequency</span></code> of type <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p></li>
<li><p>A phase <code class="docutils literal notranslate"><span class="pre">phase</span></code> of type <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p></li>
<li><p>A time of type <code class="docutils literal notranslate"><span class="pre">duration</span></code> which is manipulated implicitly and cannot be modified other
than through the existing timing instructions of <code class="docutils literal notranslate"><span class="pre">delay</span></code>, <code class="docutils literal notranslate"><span class="pre">play</span></code>, <code class="docutils literal notranslate"><span class="pre">capture</span></code>,  and <code class="docutils literal notranslate"><span class="pre">barrier</span></code>.
The time increment is determined by the port on which the frame is played (see <span class="xref std std-ref">Timing</span> section).</p></li>
</ol>
<p>A <code class="docutils literal notranslate"><span class="pre">frame</span></code> from an existing calibration can also be accessed via an <code class="docutils literal notranslate"><span class="pre">extern</span></code> identifier</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="kt">extern</span><span class="w"> </span><span class="kt">frame</span><span class="w"> </span><span class="n">xy_frame0</span>
</pre></div>
</div>
<p>Note that a <code class="docutils literal notranslate"><span class="pre">frame</span></code> type is a virtual resource and it is up to the hardware vendor’s backend compiler
to choose how to implement the required transformations to physical resources in hardware during the machine code
generation phase.</p>
<section id="frame-initialization">
<h3>Frame Initialization<a class="headerlink" href="#frame-initialization" title="Permalink to this heading">¶</a></h3>
<p>Frames can be initialized using the <code class="docutils literal notranslate"><span class="pre">newframe</span></code> command by providing the <code class="docutils literal notranslate"><span class="pre">port</span></code>, <code class="docutils literal notranslate"><span class="pre">frequency</span></code>, and <code class="docutils literal notranslate"><span class="pre">phase</span></code> e.g.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">drive0</span><span class="p">;</span>
<span class="kt">frame</span><span class="w"> </span><span class="n">driveframe0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">drive0</span><span class="p">,</span><span class="w"> </span><span class="mf">5e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// newframe(port pr, float[size] frequency, angle[size] phase)</span>
</pre></div>
</div>
<p>would initialize a frame on the <code class="docutils literal notranslate"><span class="pre">drive0</span></code> port with a frequency of 5 GHz, and phase of 0.0. Importantly,
a frame can be initializated in either a <code class="docutils literal notranslate"><span class="pre">cal</span></code> or <code class="docutils literal notranslate"><span class="pre">defcal</span></code> block which means that the time with which it is
initialized is the start time of the containing block (see <span class="xref std std-ref">Timing</span> section for more details).</p>
<p>If a compiler toolchain is unable to support the initialization of <code class="docutils literal notranslate"><span class="pre">frame</span></code>s within <code class="docutils literal notranslate"><span class="pre">defcal</span></code>s, it is expected
to raise a compile-time error when such an initialization is encountered.</p>
<p>Note that multiple frames may address the same port e.g.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">measure_port</span><span class="p">;</span>
<span class="kt">frame</span><span class="w"> </span><span class="n">measure_frame_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">measure_port</span><span class="p">,</span><span class="w"> </span><span class="mf">5e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="kt">frame</span><span class="w"> </span><span class="n">measure_frame_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">measure_port</span><span class="p">,</span><span class="w"> </span><span class="mf">5e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="kt">frame</span><span class="w"> </span><span class="n">measure_frame_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">measure_port</span><span class="p">,</span><span class="w"> </span><span class="mf">5e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="kt">frame</span><span class="w"> </span><span class="n">measure_frame_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">measure_port</span><span class="p">,</span><span class="w"> </span><span class="mf">5e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
</pre></div>
</div>
<p>The limitation on the number of frames that may address the same port depends entirely on hardware vendor
and how they choose to map <code class="docutils literal notranslate"><span class="pre">frame</span></code>s to physical resources during the backend machine code generation phase.
For example, a hardware vendor may choose to collapse all <code class="docutils literal notranslate"><span class="pre">frame</span></code>s attached to the same port into to a single
NCO in analogy to virtual to physical register allocation.</p>
</section>
<section id="frame-manipulation">
<h3>Frame Manipulation<a class="headerlink" href="#frame-manipulation" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">phase</span></code> and <code class="docutils literal notranslate"><span class="pre">frequency</span></code> states of a frame can be manipulated throughout the program
by using <code class="docutils literal notranslate"><span class="pre">set</span></code> and <code class="docutils literal notranslate"><span class="pre">shift</span></code> instructions and read using a <code class="docutils literal notranslate"><span class="pre">get</span></code> instruction. In particular,
the <cite>set_phase</cite> and <cite>shift_phase</cite> instructions allow one to supply the frame and a value of type
<code class="docutils literal notranslate"><span class="pre">angle</span></code> representing the amount by which to set/shift the phase.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="nb">set_phase</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">fr</span><span class="p">,</span><span class="w"> </span><span class="kt">angle</span><span class="w"> </span><span class="n">phase</span><span class="p">);</span>
<span class="nb">shift_phase</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">fr</span><span class="p">,</span><span class="w"> </span><span class="kt">angle</span><span class="w"> </span><span class="n">phase</span><span class="p">);</span>
</pre></div>
</div>
<p>The <cite>get_phase</cite> instruction allows one to supply the frame from which to retrieve the phase of
type <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="nb">get_phase</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">fr</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">angle</span><span class="p">;</span>
</pre></div>
</div>
<p>Analogously, the <cite>set_frequency</cite> and <cite>shift_frequency</cite> instructions allow one to supply the frame
and a value of type <code class="docutils literal notranslate"><span class="pre">float</span></code> representing the amount by which to set/shift the frequency.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="nb">set_frequency</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">fr</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="p">);</span>
<span class="nb">shift_frequency</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">fr</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="p">);</span>
</pre></div>
</div>
<p>The <cite>get_frequency</cite> instruction allows one to supply the frame from which to retrieve the frequency
of type <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="nb">get_frequency</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">fr</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">float</span><span class="p">;</span>
</pre></div>
</div>
<p>Changing the frequency or phase behaves as an instantaneous operation (ie., its
duration is zero device ticks) at the current time point of the frame. If a vendor
is unable to support such instantaneous operations, it is expected that the
compiler shall raise a compile-time error when encountering such frame manipulations.</p>
<p>The exact precision and range of the frequency is hardware specific, and it is likely
hardware vendors will perform a float to fixed conversion in the backend. If the frequency
is set to an out of bounds value, the compiler shall raise a compile-time error.</p>
<p>Here’s an example of manipulating the phase to calibrate an <code class="docutils literal notranslate"><span class="pre">rz</span></code> gate on a frame called
<code class="docutils literal notranslate"><span class="pre">driveframe</span></code>:</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="c1">// Shift phase of the &quot;drive&quot; frame by pi/4, to realize a virtual rz gate with angle -pi/4</span>
<span class="n">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">shift_phase</span><span class="p">(</span><span class="n">driveframe</span><span class="p">,</span><span class="w"> </span><span class="no">pi</span><span class="o">/</span><span class="m">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// The following is an example only. Frames as arrays has not been agreed on.</span>
<span class="c1">// This conceptually must be compile-time arrays and treat qubits as indices</span>
<span class="c1">// which also has not been well-defined. We are exploring other solutions to</span>
<span class="c1">// the problem of mapping qubits to pulse-level resources.</span>

<span class="c1">// Define a calibration for the rz gate on all 8 physical qubits</span>
<span class="n">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">array</span><span class="p">[</span><span class="kt">frame</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">]</span><span class="w"> </span><span class="n">rz_frames</span><span class="p">;</span>
<span class="w">  </span><span class="kt">frame</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="err">...</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// and so on</span>
<span class="p">}</span>

<span class="n">defcal</span><span class="w"> </span><span class="nf">rz</span><span class="p">(</span><span class="kt">angle</span><span class="p">[</span><span class="m">20</span><span class="p">]</span><span class="w"> </span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">shift_phase</span><span class="p">(</span><span class="n">rz_frames</span><span class="p">[</span><span class="n">q</span><span class="p">],</span><span class="w"> </span><span class="o">-</span><span class="n">theta</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Manipulating frames based on the state of other frames is also permitted:</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="kt">angle</span><span class="w"> </span><span class="n">temp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">get_phase</span><span class="p">(</span><span class="n">frame1</span><span class="p">);</span>
<span class="kt">angle</span><span class="w"> </span><span class="n">temp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">get_phase</span><span class="p">(</span><span class="n">frame2</span><span class="p">);</span>
<span class="nb">set_phase</span><span class="p">(</span><span class="n">frame1</span><span class="p">,</span><span class="w"> </span><span class="n">temp2</span><span class="p">);</span>
<span class="nb">set_phase</span><span class="p">(</span><span class="n">frame2</span><span class="p">,</span><span class="w"> </span><span class="n">temp1</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="waveforms">
<h2>Waveforms<a class="headerlink" href="#waveforms" title="Permalink to this heading">¶</a></h2>
<p>Waveforms are of type <code class="docutils literal notranslate"><span class="pre">waveform</span></code> and can either be:</p>
<ul class="simple">
<li><p>An array of complex samples (note this syntax is still under [active development](<a class="reference external" href="https://github.com/Qiskit/openqasm/pull/301">https://github.com/Qiskit/openqasm/pull/301</a>) and is subject to change.) which define the points for the waveform envelope</p></li>
<li><p>An abstract mathematical function representing a waveform. This will later be
materialized into a list of complex samples, either by the compiler or the
hardware using the parameters provided to the <code class="docutils literal notranslate"><span class="pre">extern</span></code> declared waveform template.</p></li>
</ul>
<p>A value of type <code class="docutils literal notranslate"><span class="pre">waveform</span></code> may be defined either by explicitly constructing the complex samples
or by calling one of the waveform template functions provided by the target device.
Note that each of these extern functions takes a type <code class="docutils literal notranslate"><span class="pre">duration</span></code> as an argument,
since waveforms must have a definite duration.
Using the hardware dependent <code class="docutils literal notranslate"><span class="pre">dt</span></code> unit is recommended for this duration,
since otherwise the compiler may need to down-sample a higher precision
waveform to physically realize it.</p>
<p>Like other extern functions, <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">waveform</span></code> functions will be compiled.
But for static waveforms, the optimizing compiler should decide to execute this
at compile time and load the waveform into memory once.
For dynamic waveforms, the compiler just compiles and links this, to be executed at runtime.
We provide the <code class="docutils literal notranslate"><span class="pre">waveform</span></code> type in addition to the complex list of samples to
provide more context to compilers and hardware. For example, some hardware pulse
generators may have optimized implementations of common pulse shapes like gaussians.
Providing structured gaussian parameters instead of the materialized list of complex
samples provides optimization opportunities that wouldn’t be available otherwise.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="c1">// arbitrary complex samples</span>
<span class="kt">waveform</span><span class="w"> </span><span class="n">arb_waveform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="o">+</span><span class="mf">0im</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="o">+</span><span class="mf">1im</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="o">/</span><span class="nb">sqrt</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="o">+</span><span class="m">1</span><span class="o">/</span><span class="nb">sqrt</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="n">im</span><span class="p">];</span>

<span class="c1">// amp is waveform amplitude at center</span>
<span class="c1">// d is the overall duration of the waveform</span>
<span class="c1">// sigma is the standard deviation of waveform</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">gaussian</span><span class="p">(</span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">]]</span><span class="w"> </span><span class="n">amp</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">sigma</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// amp is waveform amplitude at center</span>
<span class="c1">// d is the overall duration of the waveform</span>
<span class="c1">// sigma is the standard deviation of waveform</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">sech</span><span class="p">(</span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">]]</span><span class="w"> </span><span class="n">amp</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">sigma</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// amp is waveform amplitude at center</span>
<span class="c1">// d is the overall duration of the waveform</span>
<span class="c1">// square_width is the width of the square waveform component</span>
<span class="c1">// sigma is the standard deviation of waveform</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">gaussian_square</span><span class="p">(</span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">]]</span><span class="w"> </span><span class="n">amp</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">square_width</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">sigma</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// amp is waveform amplitude at center</span>
<span class="c1">// d is the overall duration of the waveform</span>
<span class="c1">// sigma is the standard deviation of waveform</span>
<span class="c1">// beta is the Y correction amplitude, see the DRAG paper</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">drag</span><span class="p">(</span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">]]</span><span class="w"> </span><span class="n">amp</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">sigma</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="w"> </span><span class="n">beta</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// amp is waveform amplitude</span>
<span class="c1">// d is the overall duration of the waveform</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">]]</span><span class="w"> </span><span class="n">amp</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// amp is waveform amplitude</span>
<span class="c1">// d is the overall duration of the waveform</span>
<span class="c1">// frequency is the frequency of the waveform</span>
<span class="c1">// phase is the phase of the waveform</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">sine</span><span class="p">(</span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">]]</span><span class="w"> </span><span class="n">amp</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w">  </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="w"> </span><span class="n">frequency</span><span class="p">,</span><span class="w"> </span><span class="kt">angle</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="w"> </span><span class="n">phase</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>
</pre></div>
</div>
<p>We can manipulate the <code class="docutils literal notranslate"><span class="pre">waveform</span></code> types using the following signal processing functions to produce
new waveforms (this list may be updated as more functionality is required).</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="c1">// Multiply two input waveforms entry by entry to produce a new waveform</span>
<span class="c1">// :math:`wf(t_i) = wf_1(t_i) \times wf_2(t_i)`</span>
<span class="nb">mix</span><span class="p">(</span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf1</span><span class="p">,</span><span class="w"> </span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// Sum two input waveforms entry by entry to produce a new waveform</span>
<span class="c1">// :math:`wf(t_i) = wf_1(t_i) + wf_2(t_i)`</span>
<span class="nb">sum</span><span class="p">(</span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf1</span><span class="p">,</span><span class="w"> </span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// Add a relative phase to a waveform (ie multiply by :math:`e^{\imag \theta}`)</span>
<span class="nb">phase_shift</span><span class="p">(</span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf</span><span class="p">,</span><span class="w"> </span><span class="kt">angle</span><span class="w"> </span><span class="n">ang</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// Scale the amplitude of a waveform&#39;s samples producing a new waveform</span>
<span class="nb">scale</span><span class="p">(</span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">factor</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="play-instruction">
<h2>Play instruction<a class="headerlink" href="#play-instruction" title="Permalink to this heading">¶</a></h2>
<p>Waveforms are scheduled using the <code class="docutils literal notranslate"><span class="pre">play</span></code> instruction. These instructions may
only appear inside a <code class="docutils literal notranslate"><span class="pre">defcal</span></code> block and have two required parameters:</p>
<ul class="simple">
<li><p>The frame to use for the pulse.</p></li>
<li><p>A value of type <code class="docutils literal notranslate"><span class="pre">waveform</span></code> representing the waveform envelope.</p></li>
</ul>
<p>Here, the <code class="docutils literal notranslate"><span class="pre">frame</span></code> provides the time at which the <code class="docutils literal notranslate"><span class="pre">waveform</span></code> envelope is scheduled (i.e. via
the frame’s current <code class="docutils literal notranslate"><span class="pre">time</span></code>), its carrier frequency (i.e. via the frames current <code class="docutils literal notranslate"><span class="pre">frequency</span></code>),
and its phase offset (i.e. via the frame’s current <code class="docutils literal notranslate"><span class="pre">phase</span></code>).</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="nb">play</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">fr</span><span class="p">,</span><span class="w"> </span><span class="kt">waveform</span><span class="w"> </span><span class="n">wfm</span><span class="p">)</span>
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="n">defcal</span><span class="w"> </span><span class="n">play_my_pulses</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Play a 3 sample pulse on the tx0 port</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="o">+</span><span class="mf">0im</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="o">+</span><span class="mf">1im</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="o">/</span><span class="nb">sqrt</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="o">+</span><span class="m">1</span><span class="o">/</span><span class="nb">sqrt</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="n">im</span><span class="p">]);</span>

<span class="w">  </span><span class="c1">// Play a gaussian pulse on the tx1 port</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span><span class="w"> </span><span class="n">q1_freq</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="w"> </span><span class="nf">gaussian</span><span class="p">(</span><span class="err">...</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">waveform</span></code> duration is not realizable by the sample rate of the associated <code class="docutils literal notranslate"><span class="pre">port</span></code>,
the compiler shall raise a compile-time error.</p>
</section>
<section id="capture-instruction">
<h2>Capture Instruction<a class="headerlink" href="#capture-instruction" title="Permalink to this heading">¶</a></h2>
<p>Acquisition is scheduled by a <code class="docutils literal notranslate"><span class="pre">capture</span></code> instruction. This is a special
<code class="docutils literal notranslate"><span class="pre">extern</span></code> function which is specified by a hardware vendor. The measurement
process is difficult to describe generically due to the wide variety of
hardware and measurement methods. Like the <code class="docutils literal notranslate"><span class="pre">play</span></code> instruction, these instructions
may only appear inside a <code class="docutils literal notranslate"><span class="pre">defcal</span></code> or <code class="docutils literal notranslate"><span class="pre">cal</span></code> block.</p>
<p>The minimum requirement for a <code class="docutils literal notranslate"><span class="pre">capture</span></code> command is that the <code class="docutils literal notranslate"><span class="pre">frame</span></code> provides the time at
which data is captured. As such, the only required parameter for a <code class="docutils literal notranslate"><span class="pre">capture</span></code> instruction
is a <code class="docutils literal notranslate"><span class="pre">frame</span></code>.</p>
<p>However, the following are possible parameters that might also be included:</p>
<ul class="simple">
<li><p>A “duration” of type <code class="docutils literal notranslate"><span class="pre">duration</span></code>, if it cannot be inferred from other parameters.</p></li>
<li><p>A “filter” of type <code class="docutils literal notranslate"><span class="pre">waveform</span></code>, which is dot product-ed with the measured IQ to distill the
result into a single IQ value</p></li>
</ul>
<p>Again it is up to the hardware vendor to determine the parameters and write a
extern definition at the top-level, such as:</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="c1">// Minimum requirement</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">capture_v0</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">output</span><span class="p">);</span>

<span class="c1">// A capture command that returns an iq value</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">capture_v1</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">waveform</span><span class="w"> </span><span class="n">filter</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="m">32</span><span class="p">]];</span>

<span class="c1">// A capture command that returns a discrimnated bit</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">capture_v2</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">waveform</span><span class="w"> </span><span class="n">filter</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bit</span><span class="p">;</span>

<span class="c1">// A capture command that returns a raw waveform data</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">capture_v3</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">waveform</span><span class="p">;</span>

<span class="c1">// A capture that returns a count e.g. number of photons detected</span>
<span class="kt">extern</span><span class="w"> </span><span class="nf">capture_v4</span><span class="p">(</span><span class="kt">frame</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span>
</pre></div>
</div>
<p>The return type of a <code class="docutils literal notranslate"><span class="pre">capture</span></code> command varies. It could be a raw trace, ie., a
list of samples taken over a short period of time. It could be some averaged IQ
value. It could be a classified bit. Or it could even have no return value,
pushing the results into some buffer which is then accessed outside the program.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">capture</span></code> instruction could return raw waveform data that is then
discriminated using user-defined boxcar and discrimination <code class="docutils literal notranslate"><span class="pre">extern</span></code>s.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Use a boxcar function to generate IQ data from raw waveform</span>
<span class="w">    </span><span class="kt">extern</span><span class="w"> </span><span class="nf">boxcar</span><span class="p">(</span><span class="kt">waveform</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="m">64</span><span class="p">]];</span>
<span class="w">    </span><span class="c1">// Use a linear discriminator to generate bits from IQ data</span>
<span class="w">    </span><span class="kt">extern</span><span class="w"> </span><span class="nf">discriminate</span><span class="p">(</span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="m">64</span><span class="p">]]</span><span class="w"> </span><span class="n">iq</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bit</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Define the ports</span>
<span class="w">    </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">m0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">cap0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">measure</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// Force time of carrier to 0 for consistent phase for discrimination.</span>
<span class="w">    </span><span class="kt">frame</span><span class="w"> </span><span class="n">stimulus_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span><span class="w"> </span><span class="mf">5e9</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">frame</span><span class="w"> </span><span class="n">capture_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">cap0</span><span class="p">,</span><span class="w"> </span><span class="mf">5e9</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Measurement stimulus envelope</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">meas_wf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">gaussian_square</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">16000dt</span><span class="p">,</span><span class="w"> </span><span class="mf">262dt</span><span class="p">,</span><span class="w"> </span><span class="mf">13952dt</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Play the stimulus</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">stimulus_frame</span><span class="p">,</span><span class="w"> </span><span class="n">meas_wf</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Align measure and capture frames</span>
<span class="w">    </span><span class="ow">barrier</span><span class="w"> </span><span class="n">stimulus_frame</span><span class="p">,</span><span class="w"> </span><span class="n">capture_frame</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Capture transmitted data after interaction with measurement resonator</span>
<span class="w">    </span><span class="c1">// extern capture_v1(frame capture_frame, duration duration) -&gt; waveform;</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">raw_output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">capture_v1</span><span class="p">(</span><span class="n">capture_frame</span><span class="p">,</span><span class="w"> </span><span class="mf">16000dt</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Kernel and discriminate</span>
<span class="w">    </span><span class="kt">complex</span><span class="p">[</span><span class="kt">float</span><span class="p">[</span><span class="m">32</span><span class="p">]]</span><span class="w"> </span><span class="n">iq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">boxcar</span><span class="p">(</span><span class="n">raw_output</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bit</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">discriminate</span><span class="p">(</span><span class="n">iq</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">duration</span></code> argument or the <code class="docutils literal notranslate"><span class="pre">waveform</span></code> duration are not realizable by the sample rate of
the associated <code class="docutils literal notranslate"><span class="pre">port</span></code>, the compiler shall raise a compile-time error.</p>
</section>
<section id="timing">
<h2>Timing<a class="headerlink" href="#timing" title="Permalink to this heading">¶</a></h2>
<p>Each frame maintains its own “clock” of type <code class="docutils literal notranslate"><span class="pre">duration</span></code>, which can only be manipulated implicitly
through the existing timing instructions of <code class="docutils literal notranslate"><span class="pre">delay</span></code>, <code class="docutils literal notranslate"><span class="pre">play</span></code>, <code class="docutils literal notranslate"><span class="pre">capture</span></code>,  and <code class="docutils literal notranslate"><span class="pre">barrier</span></code>.</p>
<section id="initial-time">
<h3>Initial Time<a class="headerlink" href="#initial-time" title="Permalink to this heading">¶</a></h3>
<p>As briefly discussed in the <span class="xref std std-ref">Frame Initialization</span> section, a <code class="docutils literal notranslate"><span class="pre">frame</span></code> initialized via a
<code class="docutils literal notranslate"><span class="pre">newframe</span></code> command has its <code class="docutils literal notranslate"><span class="pre">.time</span></code> set to the time at the beginning of the containing
<code class="docutils literal notranslate"><span class="pre">cal</span></code> or <code class="docutils literal notranslate"><span class="pre">defcal</span></code> block. Since a <code class="docutils literal notranslate"><span class="pre">cal</span></code> block is globally scoped in OpenPulse, this time
would be absolute 0. Meanwhile, a <code class="docutils literal notranslate"><span class="pre">defcal</span></code>s start time is determined by when it is scheduled
(see <span class="xref std std-ref">Timing</span> section for more details) e.g.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">d0</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// initialized with absolute time 0 because `cal` is global scope</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">driveframe1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">gaussian</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">16ns</span><span class="p">,</span><span class="w"> </span><span class="mf">4ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">my_gate1</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe1</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">my_gate2</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// initialized to time at beginning of `my_gate2`</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">driveframe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe2</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">my_gate3</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// initialized to time at beginning of `my_gate3`</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">driveframe3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe3</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// driveframe1.time = 0ns when `play(driveframe1, wf)` is issued, advances to 16ns after `play`</span>
<span class="n">my_gate1</span><span class="w"> </span><span class="l">$0</span><span class="p">;</span>
<span class="c1">// driveframe2.time = 16ns when initialized via `newframe`</span>
<span class="n">my_gate2</span><span class="w"> </span><span class="l">$0</span><span class="p">;</span>
<span class="c1">// driveframe3.time = 32ns when initialized via `newframe`</span>
<span class="n">my_gate3</span><span class="w"> </span><span class="l">$0</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="delay">
<h3>Delay<a class="headerlink" href="#delay" title="Permalink to this heading">¶</a></h3>
<p>When a <code class="docutils literal notranslate"><span class="pre">delay</span></code> instruction is issued for a list of <code class="docutils literal notranslate"><span class="pre">frame</span></code>s, the <code class="docutils literal notranslate"><span class="pre">frame</span></code> clocks advance
by the requested duration.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="c1">// driveframe advances by 13ns</span>
<span class="ow">delay</span><span class="p">[</span><span class="mf">13ns</span><span class="p">]</span><span class="w"> </span><span class="n">driveframe</span><span class="p">;</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">duration</span></code> argument of the delay is not realizable by the sample rate of
the underlying <code class="docutils literal notranslate"><span class="pre">port</span></code>, the compiler shall raise a compile-time error.</p>
</section>
<section id="play-and-capture">
<h3>Play and Capture<a class="headerlink" href="#play-and-capture" title="Permalink to this heading">¶</a></h3>
<p>When a <code class="docutils literal notranslate"><span class="pre">play</span></code> or <code class="docutils literal notranslate"><span class="pre">capture</span></code> instruction is issued, the <code class="docutils literal notranslate"><span class="pre">frame</span></code> clock advances
by the duration of the associated <code class="docutils literal notranslate"><span class="pre">waveform</span></code> argument.</p>
<div class="highlight-openpulse notranslate"><div class="highlight"><pre><span></span><span class="n">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">d0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">driveframe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">gaussian</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">16ns</span><span class="p">,</span><span class="w"> </span><span class="mf">4ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="ow">delay</span><span class="p">[</span><span class="mf">13ns</span><span class="p">]</span><span class="w"> </span><span class="n">driveframe</span><span class="p">;</span>
<span class="c1">// driveframe.time is now 13ns</span>

<span class="nb">play</span><span class="p">(</span><span class="n">driveframe</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="c1">// driveframe.time is now 29ns</span>
</pre></div>
</div>
</section>
<section id="barrier">
<h3>Barrier<a class="headerlink" href="#barrier" title="Permalink to this heading">¶</a></h3>
<p>When a <code class="docutils literal notranslate"><span class="pre">barrier</span></code> instruction is issued for a list of <code class="docutils literal notranslate"><span class="pre">frame</span></code>s, the <code class="docutils literal notranslate"><span class="pre">frame</span></code> clocks are
aligned to the latest time of the all <code class="docutils literal notranslate"><span class="pre">frame</span></code>s listed.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">d0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">d1</span><span class="p">;</span>

<span class="w">  </span><span class="n">driveframe1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.1e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="n">driveframe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="mf">5.2e9</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>

<span class="w">  </span><span class="ow">delay</span><span class="p">[</span><span class="mf">13ns</span><span class="p">]</span><span class="w"> </span><span class="n">driveframe1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// driveframe1.time == 13ns, driveframe2.time == 0ns</span>

<span class="w">  </span><span class="c1">// Align frames</span>
<span class="w">  </span><span class="ow">barrier</span><span class="w"> </span><span class="n">driveframe1</span><span class="p">,</span><span class="w"> </span><span class="n">driveframe2</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// driveframe1.time == driveframe2.time == 13ns</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Moreover, <code class="docutils literal notranslate"><span class="pre">defcal</span></code> blocks have an implicit <code class="docutils literal notranslate"><span class="pre">barrier</span></code> on every frame enters the block e.g.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">tx0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">tx1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">waveform</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... some 100ns waveform ... */</span><span class="p">;</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">driveframe1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">tx0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0e9</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">driveframe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">tx1</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0e9</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">two_qubit_gate</span><span class="w"> </span><span class="l">$1</span><span class="w"> </span><span class="l">$2</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// implicit: barrier driveframe1, driveframe2;</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe1</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe2</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">single_qubit_gate</span><span class="w"> </span><span class="l">$1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// implicit: barrier driveframe1;</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe1</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">single_qubit_gate</span><span class="w"> </span><span class="l">$1</span><span class="p">;</span>
<span class="c1">// Implicit alignment of `driveframe1` and `driveframe2` when entering `two_qubit_gate` block</span>
<span class="n">two_qubit_gate</span><span class="w"> </span><span class="l">$1</span><span class="w"> </span><span class="l">$2</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="phase-tracking">
<h3>Phase tracking<a class="headerlink" href="#phase-tracking" title="Permalink to this heading">¶</a></h3>
<p>As discussed in the <span class="xref std std-ref">Frame Manipulation</span> section, the accrued phase of a frame can be
manipulated throughout a program via <code class="docutils literal notranslate"><span class="pre">set_phase</span></code> and <code class="docutils literal notranslate"><span class="pre">shift_phase</span></code> instructions. In addition,
the phase is implicitly manipulated when the time of the frame is advanced using a <code class="docutils literal notranslate"><span class="pre">delay</span></code>,
<code class="docutils literal notranslate"><span class="pre">play</span></code>, or <code class="docutils literal notranslate"><span class="pre">capture</span></code> instruction e.g.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">tx0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">waveform</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* ... some 100ns waveform ... */</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Frame initialized with accrued phase of 0</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">driveframe0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">tx0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0e9</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">single_qubit_gate</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe0</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">single_qubit_delay</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="ow">delay</span><span class="p">[</span><span class="mf">13ns</span><span class="p">]</span><span class="w"> </span><span class="n">driveframe0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// get_phase(driveframe0) == 0</span>
<span class="n">single_qubit_gate</span><span class="w"> </span><span class="l">$0</span><span class="p">;</span>
<span class="c1">// Implicit advancement: -&gt; shift_phase(driveframe0, 2π * get_frequency(driveframe0) * durationof(wf))</span>
<span class="c1">//                        = shift_phase(driveframe0, 2π * 5e9 * 100e-9)</span>

<span class="c1">// Change the frequency</span>
<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">set_frequency</span><span class="p">(</span><span class="n">driveframe0</span><span class="p">,</span><span class="w"> </span><span class="mf">6e9</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">single_qubit_delay</span><span class="w"> </span><span class="l">$0</span><span class="p">;</span>
<span class="c1">// Implicit advancement: -&gt; set_phase(driveframe0, 2π * get_frequency(driveframe0) * 13e-9)</span>
<span class="c1">//                        = set_phase(driveframe0, 2π * 6e9 * 13e-9)</span>
</pre></div>
</div>
<p>This is a key property required for pulses to be defined in the rotating frame with the effect
being an equivalent application in the lab frame.</p>
</section>
<section id="collisions">
<h3>Collisions<a class="headerlink" href="#collisions" title="Permalink to this heading">¶</a></h3>
<p>If a frame is scheduled or referenced simultaneously in two <code class="docutils literal notranslate"><span class="pre">defcal</span></code> or <code class="docutils literal notranslate"><span class="pre">cal</span></code> blocks, it is
considered a compile-time error e.g.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">single_qubit_gate</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe1</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">single_qubit_gate</span><span class="w"> </span><span class="l">$1</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe1</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Compile-time error when requesting parallel usage of the same frame</span>
<span class="n">single_qubit_gate</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="l">$1</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h2>
<section id="rabi-spectroscopy">
<h3>Rabi Spectroscopy<a class="headerlink" href="#rabi-spectroscopy" title="Permalink to this heading">¶</a></h3>
<p>Rabi spectroscopy experiments consist of a pulse that drives the qubit transition followed by a
measurement. Exploring the response to sweeps of pulse frequency, time, amplitude, or even
multi-dimensional sweeps reveals spectroscopic information about the qubit transition frequencies
and the drive strength. We describe these circuits with a mixture of conventional OpenQASM for the
simple pulse and measure sequence and step into <cite>cal</cite> blocks to access pulse level control. We
assume that the OpenQASM text is generated by some higher level language bindings and we only write
into the program the sweep where we can take advantage of the execution speed of sweeping as part of
the program.</p>
<p><strong>Qubit Spectroscopy</strong></p>
<p>Here we want to sweep the frequency of a long pulse that saturates the qubit transition.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="c1">// sweep parameters would be programmed in by some higher level bindings</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">frequency_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.5e9</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">frequency_step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e6</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">frequency_num_steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">301</span><span class="p">;</span>

<span class="c1">// define a long saturation pulse of a set duration and amplitude</span>
<span class="kd">defcal</span><span class="w"> </span><span class="nf">saturation_pulse</span><span class="w"> </span><span class="l">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// assume frame can be linked from a vendor supplied `cal` block</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe</span><span class="p">,</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">100e-6</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// step into a `cal` block to set the start of the frequency sweep</span>
<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">set_frequency</span><span class="p">(</span><span class="n">driveframe</span><span class="p">,</span><span class="w"> </span><span class="n">frequency_start</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">:</span><span class="n">frequency_num_steps</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// step into a `cal` block to adjust the pulse frequency via the frame frequency</span>
<span class="w">    </span><span class="n">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">shift_frequency</span><span class="p">(</span><span class="n">driveframe</span><span class="p">,</span><span class="w"> </span><span class="n">frequency_step</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">saturation_pulse</span><span class="w"> </span><span class="l">$0</span><span class="p">;</span>
<span class="w">    </span><span class="n">measure</span><span class="w"> </span><span class="l">$0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Rabi Time Spectroscopy</strong></p>
<p>Here we want to sweep the time of the pulse and observe coherent Rabi flopping dynamics.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="kt">const</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">pulse_length_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20dt</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">pulse_length_step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1dt</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pulse_length_num_steps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">:</span><span class="n">pulse_length_num_steps</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">duration</span><span class="w"> </span><span class="n">pulse_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pulse_length_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="o">*</span><span class="n">pulse_length_step</span><span class="p">);</span>
<span class="w">    </span><span class="kt">duration</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pulse_length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">4</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// since we are manipulating pulse lengths it is easier to define and play the waveform in a `cal` block</span>
<span class="w">    </span><span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">gaussian</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">pulse_length</span><span class="p">,</span><span class="w"> </span><span class="n">sigma</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// assume frame can be linked from a vendor supplied `cal` block</span>
<span class="w">        </span><span class="nb">play</span><span class="p">(</span><span class="n">driveframe</span><span class="p">,</span><span class="w"> </span><span class="n">wf</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="ow">measure</span><span class="w"> </span><span class="l">$0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="cross-resonance-gate">
<h3>Cross-resonance gate<a class="headerlink" href="#cross-resonance-gate" title="Permalink to this heading">¶</a></h3>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// Access globally (or externally) defined ports</span>
<span class="w">   </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">d0</span><span class="p">;</span>
<span class="w">   </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">d1</span><span class="p">;</span>
<span class="w">   </span><span class="kt">frame</span><span class="w"> </span><span class="n">frame0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0e9</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">cross_resonance</span><span class="w"> </span><span class="l">$0</span><span class="p">,</span><span class="w"> </span><span class="l">$1</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">gaussian_square</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1024dt</span><span class="p">,</span><span class="w"> </span><span class="mf">128dt</span><span class="p">,</span><span class="w"> </span><span class="mf">32dt</span><span class="p">);</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">wf2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">gaussian_square</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">1024dt</span><span class="p">,</span><span class="w"> </span><span class="mf">128dt</span><span class="p">,</span><span class="w"> </span><span class="mf">32dt</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*** Do pre-rotation ***/</span>

<span class="w">    </span><span class="c1">// generate new frame for second drive that is locally scoped</span>
<span class="w">    </span><span class="c1">// initialized to time at the beginning of `cross_resonance`</span>
<span class="w">    </span><span class="kt">frame</span><span class="w"> </span><span class="n">temp_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="nb">get_frequency</span><span class="p">(</span><span class="n">frame0</span><span class="p">),</span><span class="w"> </span><span class="nb">get_phase</span><span class="p">(</span><span class="n">frame0</span><span class="p">));</span>

<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">frame0</span><span class="p">,</span><span class="w"> </span><span class="n">wf1</span><span class="p">);</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">temp_frame</span><span class="p">,</span><span class="w"> </span><span class="n">wf2</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*** Do post-rotation ***/</span>

<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="geometric-gate">
<h3>Geometric gate<a class="headerlink" href="#geometric-gate" title="Permalink to this heading">¶</a></h3>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">dq</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fq_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5e9</span><span class="p">;</span><span class="w"> </span><span class="c1">// hardcode or pull from some function</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">anharm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">300e6</span><span class="p">;</span><span class="w"> </span><span class="c1">// hardcode or pull from some function</span>
<span class="w">    </span><span class="kt">frame</span><span class="w"> </span><span class="n">frame_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span><span class="w"> </span><span class="n">fq_01</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">frame</span><span class="w"> </span><span class="n">frame_12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span><span class="w"> </span><span class="n">fq_01</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">anharm</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">geo_gate</span><span class="p">(</span><span class="kt">angle</span><span class="p">[</span><span class="m">32</span><span class="p">]</span><span class="w"> </span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// theta: rotation angle (about z-axis) on Bloch sphere</span>

<span class="w">    </span><span class="c1">// Assume we have calibrated 0-&gt;1 pi pulses and 1-&gt;2 pi pulse</span>
<span class="w">    </span><span class="c1">// envelopes (no sideband)</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">X_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">X_12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kt">float</span><span class="p">[</span><span class="m">32</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sin</span><span class="p">(</span><span class="n">theta</span><span class="o">/</span><span class="m">2</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="p">[</span><span class="m">32</span><span class="p">]</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">(</span><span class="m">1</span><span class="o">-</span><span class="n">a</span><span class="o">**</span><span class="m">2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Double-tap</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">frame_01</span><span class="p">,</span><span class="w"> </span><span class="nb">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">X_01</span><span class="p">));</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">frame_12</span><span class="p">,</span><span class="w"> </span><span class="nb">scale</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">X_12</span><span class="p">));</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">frame_01</span><span class="p">,</span><span class="w"> </span><span class="nb">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">X_01</span><span class="p">));</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">frame_12</span><span class="p">,</span><span class="w"> </span><span class="nb">scale</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">X_12</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="neutral-atoms">
<h3>Neutral atoms<a class="headerlink" href="#neutral-atoms" title="Permalink to this heading">¶</a></h3>
<p>In this example, the signal chain is composed of two electro-optic modulators (EOM) and
an acousto-optic deflector (AOD). The EOMs put sidebands on the laser light while the AOD diffracts
the light in an amount proportional to the frequency of the RF drive. This example was chosen
because it is similar in spirit to the work by Levine et al._:cite:<cite>levine2019</cite> except that phase
control is exerted using virtual Z gates on the AODs – requiring frame tracking of the qubit
frequency yet application of a tone that maps to the qubit position (i.e. requires the use of a
sideband).</p>
<p>The program aims to perform a Hahn echo sequence on q1, and a Ramsey sequence on q2 and q3.</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="c1">// Raman transition detuning Δ from the  5S1/2 to 5P1/2 transition</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Δ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>

<span class="c1">// Hyperfine qubit frequency</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">qubit_freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>

<span class="c1">// Positional frequencies for the AODS to target the specific qubit</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">q1_pos_freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">q2_pos_freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">q3_pos_freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>

<span class="c1">// Calibrated amplitudes and durations for the Raman pulses supplied via the AOD envelopes</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">q1_π_half_amp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">q2_π_half_amp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">q3_π_half_amp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">π_half_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>

<span class="c1">// Time-proportional phase increment</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">tppi_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">tppi_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">tppi_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>


<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">eom_a_port</span><span class="p">;</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">eom_b_port</span><span class="p">;</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">aod_port</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Define the Raman frames, which are detuned by an amount Δ from the  5S1/2 to 5P1/2 transition</span>
<span class="w">  </span><span class="c1">// and offset from each other by the qubit_freq</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">raman_a_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">eom_a_port</span><span class="p">,</span><span class="w"> </span><span class="n">Δ</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">raman_b_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">eom_b_port</span><span class="p">,</span><span class="w"> </span><span class="n">Δ</span><span class="o">-</span><span class="n">qubit_freq</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Three frames to phase track each qubit&#39;s rotating frame of reference at it&#39;s frequency</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">q1_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">aod_port</span><span class="p">,</span><span class="w"> </span><span class="n">qubit_freq</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">q2_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">aod_port</span><span class="p">,</span><span class="w"> </span><span class="n">qubit_freq</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">q3_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">aod_port</span><span class="p">,</span><span class="w"> </span><span class="n">qubit_freq</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Generic gaussian envelope</span>
<span class="w">  </span><span class="kt">waveform</span><span class="w"> </span><span class="n">π_half_sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">gaussian</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">π_half_time</span><span class="p">,</span><span class="w"> </span><span class="mf">100dt</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Waveforms ultimately supplied to the AODs. We mix our general Gaussian pulse with a sine wave to</span>
<span class="w">  </span><span class="c1">// put a sideband on the outgoing pulse. This helps us target the qubit position while maintainig the</span>
<span class="w">  </span><span class="c1">// desired Rabi rate.</span>
<span class="w">  </span><span class="kt">waveform</span><span class="w"> </span><span class="n">q1_π_half_sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mix</span><span class="p">(</span><span class="n">π_half_sig</span><span class="p">,</span><span class="w"> </span><span class="nf">sine</span><span class="p">(</span><span class="n">q1_π_half_amp</span><span class="p">,</span><span class="w"> </span><span class="n">π_half_time</span><span class="p">,</span><span class="w"> </span><span class="n">q1_pos_freq</span><span class="o">-</span><span class="n">qubit_freq</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="w">  </span><span class="kt">waveform</span><span class="w"> </span><span class="n">q2_π_half_sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mix</span><span class="p">(</span><span class="n">π_half_sig</span><span class="p">,</span><span class="w"> </span><span class="nf">sine</span><span class="p">(</span><span class="n">q2_π_half_amp</span><span class="p">,</span><span class="w"> </span><span class="n">π_half_time</span><span class="p">,</span><span class="w"> </span><span class="n">q2_pos_freq</span><span class="o">-</span><span class="n">qubit_freq</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="w">  </span><span class="kt">waveform</span><span class="w"> </span><span class="n">q3_π_half_sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mix</span><span class="p">(</span><span class="n">π_half_sig</span><span class="p">,</span><span class="w"> </span><span class="nf">sine</span><span class="p">(</span><span class="n">q3_π_half_amp</span><span class="p">,</span><span class="w"> </span><span class="n">π_half_time</span><span class="p">,</span><span class="w"> </span><span class="n">q3_pos_freq</span><span class="o">-</span><span class="n">qubit_freq</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// π/2 pulses on all three qubits</span>
<span class="kd">defcal</span><span class="w"> </span><span class="nf">rx</span><span class="p">(</span><span class="no">π</span><span class="o">/</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="l">$1</span><span class="w"> </span><span class="l">$2</span><span class="w"> </span><span class="l">$3</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Simultaneous π/2 pulses</span>
<span class="w">      </span><span class="nb">play</span><span class="p">(</span><span class="n">raman_a_frame</span><span class="p">,</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="n">raman_a_amp</span><span class="p">,</span><span class="w"> </span><span class="n">π_half_time</span><span class="p">));</span>
<span class="w">      </span><span class="nb">play</span><span class="p">(</span><span class="n">raman_b_frame</span><span class="p">,</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="n">raman_b_amp</span><span class="p">,</span><span class="w"> </span><span class="n">π_half_time</span><span class="p">));</span>
<span class="w">      </span><span class="nb">play</span><span class="p">(</span><span class="n">q1_frame</span><span class="p">,</span><span class="w"> </span><span class="n">q1_π_half_sig</span><span class="p">);</span>
<span class="w">      </span><span class="nb">play</span><span class="p">(</span><span class="n">q2_frame</span><span class="p">,</span><span class="w"> </span><span class="n">q2_π_half_sig</span><span class="p">);</span>
<span class="w">      </span><span class="nb">play</span><span class="p">(</span><span class="n">q3_frame</span><span class="p">,</span><span class="w"> </span><span class="n">q3_π_half_sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// π/2 pulse on only qubit $2</span>
<span class="kd">defcal</span><span class="w"> </span><span class="nf">rx</span><span class="p">(</span><span class="no">π</span><span class="o">/</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="l">$2</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">raman_a_frame</span><span class="p">,</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="n">raman_a_amp</span><span class="p">,</span><span class="w"> </span><span class="n">π_half_time</span><span class="p">));</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">raman_b_frame</span><span class="p">,</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="n">raman_b_amp</span><span class="p">,</span><span class="w"> </span><span class="n">π_half_time</span><span class="p">));</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">q2_frame</span><span class="p">,</span><span class="w"> </span><span class="n">q2_π_half_sig</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Ramsey sequence on qubit 1 and 3, Hahn echo on qubit 2</span>
<span class="k">for</span><span class="w"> </span><span class="no">τ</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[</span><span class="m">0</span><span class="p">:</span><span class="mf">10us</span><span class="p">:</span><span class="mf">1ms</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// First π/2 pulse</span>
<span class="w">  </span><span class="nf">rx</span><span class="p">(</span><span class="no">π</span><span class="o">/</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="l">$0</span><span class="p">,</span><span class="w"> </span><span class="l">$1</span><span class="p">,</span><span class="w"> </span><span class="l">$2</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// First half of evolution time</span>
<span class="w">  </span><span class="n">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="ow">delay</span><span class="p">[</span><span class="no">τ</span><span class="o">/</span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="n">raman_a_frame</span><span class="w"> </span><span class="n">raman_b_frame</span><span class="w"> </span><span class="n">q1_frame</span><span class="w"> </span><span class="n">q2_frame</span><span class="w"> </span><span class="n">q3_frame</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Hahn echo π pulse composed of two π/2 pulses</span>
<span class="w">  </span><span class="n">for</span><span class="w"> </span><span class="n">ct</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">[</span><span class="m">0</span><span class="p">:</span><span class="m">1</span><span class="p">]:</span>
<span class="w">    </span><span class="nf">rx</span><span class="p">(</span><span class="no">π</span><span class="o">/</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="l">$2</span><span class="p">;</span>

<span class="w">  </span><span class="n">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Align all frames</span>
<span class="w">    </span><span class="ow">barrier</span><span class="w"> </span><span class="n">raman_a_frame</span><span class="w"> </span><span class="n">raman_b_frame</span><span class="w"> </span><span class="n">q1_frame</span><span class="w"> </span><span class="n">q2_frame</span><span class="w"> </span><span class="n">q3_frame</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Second half of evolution time</span>
<span class="w">    </span><span class="ow">delay</span><span class="p">[</span><span class="no">τ</span><span class="o">/</span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="n">raman_a_frame</span><span class="w"> </span><span class="n">raman_b_frame</span><span class="w"> </span><span class="n">q1_frame</span><span class="w"> </span><span class="n">q2_frame</span><span class="w"> </span><span class="n">q3_frame</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Time-proportional phase increment signals different amount</span>
<span class="w">    </span><span class="nb">shift_phase</span><span class="p">(</span><span class="n">q1_frame</span><span class="p">,</span><span class="w"> </span><span class="n">tppi_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">τ</span><span class="p">);</span>
<span class="w">    </span><span class="nb">shift_phase</span><span class="p">(</span><span class="n">q2_frame</span><span class="p">,</span><span class="w"> </span><span class="n">tppi_2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">τ</span><span class="p">);</span>
<span class="w">    </span><span class="nb">shift_phase</span><span class="p">(</span><span class="n">q3_frame</span><span class="p">,</span><span class="w"> </span><span class="n">tppi_3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">τ</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Second π/2 pulse</span>
<span class="w">  </span><span class="nf">rx</span><span class="p">(</span><span class="no">π</span><span class="o">/</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="l">$0</span><span class="p">,</span><span class="w"> </span><span class="l">$1</span><span class="p">,</span><span class="w"> </span><span class="l">$2</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="multiplexed-readout-and-capture">
<h3>Multiplexed readout and capture<a class="headerlink" href="#multiplexed-readout-and-capture" title="Permalink to this heading">¶</a></h3>
<p>In this example, we want to perform readout and capture of a pair of qubits, but mediated by a
single physical transmission and capture port. The example is for just two qubits, but works the same for
many (just adding more frames, waveforms, plays, and captures).</p>
<div class="highlight-qasm3 notranslate"><div class="highlight"><pre><span></span><span class="kn">defcalgrammar</span><span class="w"> </span><span class="s">&quot;openpulse&quot;</span><span class="p">;</span>

<span class="kt">const</span><span class="w"> </span><span class="kt">duration</span><span class="w"> </span><span class="n">electrical_delay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">q0_ro_freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>
<span class="kt">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">q1_ro_freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">...</span><span class="p">;</span>

<span class="k">cal</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// the transmission/captures ports are the same for $0 and $1</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">ro_tx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">extern</span><span class="w"> </span><span class="kt">port</span><span class="w"> </span><span class="n">ro_rx</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// readout stimulus and capture frames of different frequencies</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">q0_stimulus_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">ro_tx</span><span class="p">,</span><span class="w"> </span><span class="n">q0_ro_freq</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">q0_capture_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">ro_rx</span><span class="p">,</span><span class="w"> </span><span class="n">q0_ro_freq</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">q1_stimulus_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">ro_tx</span><span class="p">,</span><span class="w"> </span><span class="n">q1_ro_freq</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">frame</span><span class="w"> </span><span class="n">q1_capture_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">newframe</span><span class="p">(</span><span class="n">ro_rx</span><span class="p">,</span><span class="w"> </span><span class="n">q1_ro_freq</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">defcal</span><span class="w"> </span><span class="nf">multiplexed_readout_and_capture</span><span class="w"> </span><span class="l">$0</span><span class="p">,</span><span class="w"> </span><span class="l">$1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bit</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bit</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// flat-top readout waveforms</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">q0_ro_wf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="n">amp</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">=</span><span class="err">...</span><span class="p">);</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">q1_ro_wf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="n">amp</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">=</span><span class="err">...</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// multiplexed readout</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">q0_stimulus_frame</span><span class="p">,</span><span class="w"> </span><span class="n">q0_ro_wf</span><span class="p">);</span>
<span class="w">    </span><span class="nb">play</span><span class="p">(</span><span class="n">q1_stimulus_frame</span><span class="p">,</span><span class="w"> </span><span class="n">q1_ro_wf</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// simple boxcar kernel</span>
<span class="w">    </span><span class="kt">waveform</span><span class="w"> </span><span class="n">ro_kernel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">constant</span><span class="p">(</span><span class="n">amp</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">=</span><span class="err">...</span><span class="p">);</span>

<span class="w">    </span><span class="ow">barrier</span><span class="w"> </span><span class="n">q0_stimulus_frame</span><span class="w"> </span><span class="n">q1_stimulus_frame</span><span class="w"> </span><span class="n">q0_capture_frame</span><span class="w"> </span><span class="n">q1_capture_frame</span><span class="p">;</span>
<span class="w">    </span><span class="ow">delay</span><span class="p">[</span><span class="n">electrical_delay</span><span class="p">]</span><span class="w"> </span><span class="n">q0_capture_frame</span><span class="w"> </span><span class="n">q1_capture_frame</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// multiplexed capture</span>
<span class="w">    </span><span class="c1">// extern capture(frame capture_frame, waveform ro_kernel) -&gt; bit;</span>
<span class="w">    </span><span class="n">b</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">capture</span><span class="p">(</span><span class="n">q0_capture_frame</span><span class="p">,</span><span class="w"> </span><span class="n">ro_kernel</span><span class="p">);</span>
<span class="w">    </span><span class="n">b</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">capture</span><span class="p">(</span><span class="n">q1_capture_frame</span><span class="p">,</span><span class="w"> </span><span class="n">ro_kernel</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="open-questions">
<h3>Open Questions<a class="headerlink" href="#open-questions" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>How do we handle mapping wildcarded qubits to arbitrary pulse-level resources?</p></li>
<li><p>Is timing on frames, and ports as resources clear?</p></li>
<li><p>How will hardware attributes be handled?</p></li>
</ul>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">OpenQASM Live Specification</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="comments.html">Comments</a></li>
<li class="toctree-l2"><a class="reference internal" href="comments.html#version-string">Version string</a></li>
<li class="toctree-l2"><a class="reference internal" href="comments.html#included-files">Included files</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types and Casting</a></li>
<li class="toctree-l2"><a class="reference internal" href="gates.html">Gates</a></li>
<li class="toctree-l2"><a class="reference internal" href="insts.html">Built-in quantum instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="classical.html">Classical instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="subroutines.html">Subroutines</a></li>
<li class="toctree-l2"><a class="reference internal" href="scope.html">Scoping of variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="directives.html">Directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="directives.html#input-output">Input/output</a></li>
<li class="toctree-l2"><a class="reference internal" href="delays.html">Circuit timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pulses.html">Pulse-level descriptions of gates and measurement</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">OpenPulse Grammar</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ports">Ports</a></li>
<li class="toctree-l3"><a class="reference internal" href="#frames">Frames</a></li>
<li class="toctree-l3"><a class="reference internal" href="#waveforms">Waveforms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#play-instruction">Play instruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#capture-instruction">Capture Instruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timing">Timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../grammar/index.html">OpenQasm 3.0 Grammar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Language</a><ul>
      <li>Previous: <a href="pulses.html" title="previous chapter">Pulse-level descriptions of gates and measurement</a></li>
      <li>Next: <a href="../grammar/index.html" title="next chapter">OpenQasm 3.0 Grammar</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017-2020, Andrew W. Cross, Lev S. Bishop, John A. Smolin, Jay M. Gambetta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/language/openpulse.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>