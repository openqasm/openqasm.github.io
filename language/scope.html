
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Scoping of variables &#8212; OpenQASM Live Specification  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/colors.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Directives" href="directives.html" />
    <link rel="prev" title="Subroutines" href="subroutines.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="scoping-of-variables">
<h1>Scoping of variables<a class="headerlink" href="#scoping-of-variables" title="Permalink to this heading">¶</a></h1>
<p>This section describes the rules surrounding scoping of variables in OpenQASM.</p>
<p>OpenQASM 3.0 has four types of scoping constructs, and the visibility of some
symbols can differ slightly between these.  The types of scope are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#scope-global"><span class="std std-ref">Global scope</span></a>, which is the current scope only when no
other scopes are active.</p></li>
<li><p><a class="reference internal" href="#scope-subroutine"><span class="std std-ref">Gate and function scope</span></a>, which is entered in the
body of <code class="docutils literal notranslate"><span class="pre">gate</span></code> and <code class="docutils literal notranslate"><span class="pre">def</span></code> definitions.</p></li>
<li><p><a class="reference internal" href="#scope-block"><span class="std std-ref">Local block scope</span></a>, which becomes active on entry to a
non-gate and non-subroutine control-flow block, such as <code class="docutils literal notranslate"><span class="pre">if</span></code> or <code class="docutils literal notranslate"><span class="pre">for</span></code>.</p></li>
<li><p>Calibration scopes, which are the shared calibration state contained in
<code class="docutils literal notranslate"><span class="pre">cal</span></code> and <code class="docutils literal notranslate"><span class="pre">defcal</span></code> blocks.  The precise rules for these may vary depending
on the particular companion calibration grammar that has been loaded for this
program.  See <span class="xref std std-ref">the OpenPulse specification</span> for details on
how this is handled in the OpenPulse calibration language.  This document will
not cover this topic further.</p></li>
</ul>
<p>In general, the lifetime of each identifier begins when it is declared, and ends
at the completion of the scope it was declared in.  The storage space for each
variable must be allocated for at least the lifetime of the identifier, but it
is up to individual implementations to define their allocation strategies within
nested scopes.</p>
<p>In order to be a valid OpenQASM 3.0 program, symbols must be defined before they
are used; in particular, there is no forward declaration of functions and gates,
and there can be no mutual recursion.</p>
<p>Most regular identifiers of variables can be shadowed in inner scopes, so that
the identifier temporarily refers to a different variable, but cannot be
re-declared without entering an inner scope.  The type of the shadowing variable
does not need to be the same as the type of the variable it is shadowing.</p>
<p>Not all identifiers declared in outer scopes are visible within inner scopes.
The visibility depends on the type of the variable, and the type of the inner
scope.  Approximately, <code class="docutils literal notranslate"><span class="pre">const</span></code> variables, gates and subroutines are visible
within <em>all</em> inner scopes, while other variables in outer scopes are visible
within inner control-flow scopes but not gate and function scopes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">include</span></code> statement should be seen as extending the global scope of the
file it is contained within; all variables that are in scope at the time of the
<code class="docutils literal notranslate"><span class="pre">include</span></code> statement are also in scope while the included file is being parsed,
and variables defined in that file will be available in the containing file’s
scope once the inclusion has been parsed.  There is no separate namespacing
defined in OpenQASM 3.0.</p>
<section id="global-scope">
<span id="scope-global"></span><h2>Global scope<a class="headerlink" href="#global-scope" title="Permalink to this heading">¶</a></h2>
<p>The global scope is active when no other scopes are active.  Several OpenQASM
3.0 statements are only valid in the global scope, such as (non-exhaustive):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gate</span></code>, <code class="docutils literal notranslate"><span class="pre">def</span></code> and <code class="docutils literal notranslate"><span class="pre">defcal</span></code> declarations,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qubit</span></code> declarations,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">array</span></code> declarations.</p></li>
</ul>
<p>A simple example of scoping between a main program file and an included file:</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-number">Listing 1 </span><span class="caption-text">Main program</span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OPENQASM</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>

<span class="n">gate</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">U</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// `U` is the single-qubit gate that is implicitly defined in the global</span>
<span class="w">   </span><span class="c1">// scope of all OpenQASM 3.0 programs, and so is available here.</span>
<span class="w">   </span><span class="c1">// Similarly `pi` is one of the implicitly defined constants.</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>

<span class="n">include</span><span class="w"> </span><span class="s">&quot;my_definitions.qasm&quot;</span><span class="p">;</span>

<span class="c1">// Identifiers &#39;h&#39;, &#39;my_gate&#39;, &#39;i&#39; and &#39;j&#39; are defined and in scope.</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-number">Listing 2 </span><span class="caption-text">File <code class="docutils literal notranslate"><span class="pre">my_definitions.qasm</span></code></span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">gate</span><span class="w"> </span><span class="n">my_gate</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">U</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="c1">// This usage of `i` is valid because the scope inside the `include`</span>
<span class="c1">// inherits all definitions from the scope that did the including.</span>
</pre></div>
</div>
</div>
<p>Within the global scope, identifiers declared by <code class="docutils literal notranslate"><span class="pre">gate</span></code>, <code class="docutils literal notranslate"><span class="pre">def</span></code> and
<code class="docutils literal notranslate"><span class="pre">defcal</span></code> statements may not be shadowed or otherwise redeclared.  As described
in the <a class="reference internal" href="pulses.html#pulse-gates"><span class="std std-ref">section on pulse-level descriptions of quantum operations</span></a>, multiple <code class="docutils literal notranslate"><span class="pre">defcal</span></code> statements may affect the same operation;
this is not an instance of shadowing, but a form of overloading, extending the
calibration definitions for different qubits.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The following example is <em>not</em> valid OpenQASM 3.0 due to invalid scoping.</p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OPENQASM</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>

<span class="n">gate</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">U</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// ERROR: &#39;h&#39; is already defined and cannot be re-declared.</span>

<span class="n">uint</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">uint</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ERROR: &#39;a&#39; is already defined and cannot be re-declared.</span>

<span class="n">defcal</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// No error: this is valid OpenQASM 3.0 because `defcal` statements do not</span>
<span class="c1">// redefine, they overload quantum operations with specific pulse-level</span>
<span class="c1">// control statements.</span>

<span class="n">defcal</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">$0</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// ERROR: &#39;a&#39; is already defined and cannot be re-declared.  Unlike the</span>
<span class="c1">// previous example, this is an error because &#39;a&#39; is already declared as a</span>
<span class="c1">// non-quantum-operation type (&#39;uint&#39;).  This `defcal` would be defining a</span>
<span class="c1">// new gate, which is invalid with &#39;a&#39; already defined.</span>
</pre></div>
</div>
</section>
<section id="subroutine-and-gate-scope">
<span id="scope-subroutine"></span><h2>Subroutine and gate scope<a class="headerlink" href="#subroutine-and-gate-scope" title="Permalink to this heading">¶</a></h2>
<p>The definitions of subroutines (<code class="docutils literal notranslate"><span class="pre">def</span></code>) and gates (<code class="docutils literal notranslate"><span class="pre">gate</span></code>) introduce a new
scope.  The <code class="docutils literal notranslate"><span class="pre">def</span></code> and <code class="docutils literal notranslate"><span class="pre">gate</span></code> statements are only valid directly within the
global scope of the program.</p>
<p>Inside the definition of the subroutine or gate, symbols that were already
defined in the global scope with the <code class="docutils literal notranslate"><span class="pre">const</span></code> modifier, or previously defined
gates and subroutines are visible.  Globally scoped variables without the
<code class="docutils literal notranslate"><span class="pre">const</span></code> modifier are not visible inside the definition.  In other words,
subroutines and gates cannot close over variables that may be modified at
run-time.</p>
<p>Variables defined in subroutine scopes are local to the subroutine body.
Variables defined in the parameter specifications of subroutines and gates
behave for scoping purposes as if they were defined in the scope of the
definition.  The lifetime of these local variables ends at the end of the
function body, and they are not accessible after the subroutine or gate body.
Similarly, the qubit identifiers in a gate definition are valid only within the
definition of the gate.</p>
<p>The identifier of a subroutine or gate is available in the scope of its own
body, allowing direct recursion.  For gates, the direct recursion is unlikely to
ever be useful, since this would generally be non-terminating.</p>
<p>Local subroutine or gate variables, including parameters and qubit definitions,
may shadow variables defined in the outer scope.  Inside the body, the
identifier will refer to the local variable instead.  After the definition of
the body has completed (and we are back in the global scope), the identifier
will refer to the same variable it did before the subroutine or gate.</p>
<p>Subroutines cannot contain <code class="docutils literal notranslate"><span class="pre">qubit</span></code> declarations in their bodies, but can
accept variables of type <code class="docutils literal notranslate"><span class="pre">qubit</span></code> in their parameter lists.  Aliases can be
declared within subroutine and gate scopes, and have the same lifetime and
visibility as other local variables.</p>
<p>For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">OPENQASM</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="n">qubit</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">all_qubits</span><span class="p">;</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos"> 6</span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="n">def</span><span class="w"> </span><span class="nf">my_routine</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">   </span><span class="c1">// In this body, &#39;a&#39; refers to the subroutine parameter, not the external</span>
<span class="linenos">12</span><span class="w">   </span><span class="c1">// variable, which wouldn&#39;t be visible even without the shadowing.</span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">in_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">   </span><span class="c1">// Identifiers in scope are:</span>
<span class="linenos">17</span><span class="w">   </span><span class="c1">//  - &#39;my_routine&#39;: the subroutine itself</span>
<span class="linenos">18</span><span class="w">   </span><span class="c1">//  - &#39;a&#39;: type &#39;uint&#39;, from the parameter list</span>
<span class="linenos">19</span><span class="w">   </span><span class="c1">//  - &#39;c&#39;: type &#39;uint&#39;, from the parameter list (shadows the outer &#39;const</span>
<span class="linenos">20</span><span class="w">   </span><span class="c1">//      int&#39; &#39;c&#39;).</span>
<span class="linenos">21</span><span class="w">   </span><span class="c1">//  - &#39;d&#39;: type &#39;const int&#39;, value 4, visible from the global scope</span>
<span class="linenos">22</span><span class="w">   </span><span class="c1">//      because it is a &#39;const&#39; type.</span>
<span class="linenos">23</span><span class="w">   </span><span class="c1">//  - &#39;in_body&#39;: type &#39;int&#39;, value 5, from regular definition in the</span>
<span class="linenos">24</span><span class="w">   </span><span class="c1">//      current scope.</span>
<span class="linenos">25</span><span class="w">   </span><span class="c1">//  - other built-in identifiers (such as &#39;U&#39; and &#39;pi&#39;) that are</span>
<span class="linenos">26</span><span class="w">   </span><span class="c1">//      implicitly defined in the global scope.</span>
<span class="linenos">27</span><span class="w">   </span><span class="c1">//  - all available hardware qubits (such as &#39;$0&#39;)</span>
<span class="linenos">28</span><span class="w">   </span><span class="c1">//</span>
<span class="linenos">29</span><span class="w">   </span><span class="c1">// The variable &#39;b&#39; is not in scope, because its visibility as a</span>
<span class="linenos">30</span><span class="w">   </span><span class="c1">// non-&#39;const&#39; type does not make it available within subroutines.  The</span>
<span class="linenos">31</span><span class="w">   </span><span class="c1">// hardware qubit identifiers are in scope, but not the virtual qubit</span>
<span class="linenos">32</span><span class="w">   </span><span class="c1">// identifier &#39;all_qubits&#39;.</span>
<span class="linenos">33</span><span class="p">}</span>
<span class="linenos">34</span>
<span class="linenos">35</span><span class="c1">// After the subroutine block, &#39;a&#39; and &#39;c&#39; once again refer to the variables</span>
<span class="linenos">36</span><span class="c1">// of type &#39;int&#39; and &#39;const int&#39; defined on lines 3 and 5 respectively.</span>
<span class="linenos">37</span><span class="c1">// &#39;in_body&#39; (from the subroutine body) is not in scope, while &#39;my_routine&#39;</span>
<span class="linenos">38</span><span class="c1">// (the subroutine) is.</span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="n">new_variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5</span><span class="p">;</span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="n">def</span><span class="w"> </span><span class="nf">second_subroutine</span><span class="p">(</span><span class="n">qubit</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">43</span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">in_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="w">   </span><span class="n">let</span><span class="w"> </span><span class="n">some_qubits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
<span class="linenos">46</span>
<span class="linenos">47</span><span class="w">   </span><span class="c1">// Identifiers in scope are:</span>
<span class="linenos">48</span><span class="w">   </span><span class="c1">//   - &#39;second_subroutine&#39;</span>
<span class="linenos">49</span><span class="w">   </span><span class="c1">//   - &#39;my_subroutine&#39;</span>
<span class="linenos">50</span><span class="w">   </span><span class="c1">//   - &#39;in_body&#39;: type &#39;int&#39;, value 8</span>
<span class="linenos">51</span><span class="w">   </span><span class="c1">//   - &#39;c&#39;: type &#39;const int&#39;, value 3</span>
<span class="linenos">52</span><span class="w">   </span><span class="c1">//   - &#39;d&#39;: type &#39;const int&#39;, value 4</span>
<span class="linenos">53</span><span class="w">   </span><span class="c1">//   - &#39;q&#39;: type &#39;qubit[4]&#39;, a virtual, run-time-known qubit register.</span>
<span class="linenos">54</span><span class="w">   </span><span class="c1">//   - &#39;some_qubits&#39;: alias for the first three qubits of &#39;q&#39;.</span>
<span class="linenos">55</span><span class="w">   </span><span class="c1">//   - &#39;new_variable&#39;: type &#39;const float[64]&#39;, value 1.5</span>
<span class="linenos">56</span><span class="w">   </span><span class="c1">//   - the other built-in identifiers like &#39;U&#39; and &#39;pi&#39;</span>
<span class="linenos">57</span><span class="w">   </span><span class="c1">//   - the available hardware qubits like &#39;$0&#39;.</span>
<span class="linenos">58</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="block-scope">
<span id="scope-block"></span><h2>Block scope<a class="headerlink" href="#block-scope" title="Permalink to this heading">¶</a></h2>
<p>Certain control-flow operations introduce their own local scope.  These
operations are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">for</span></code> loops,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">while</span></code> loops,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">else</span></code> blocks,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">box</span></code> statements.</p></li>
</ul>
<p>These scopes inherit <em>all</em> variables that are in scope in the immediately
containing scope.  Unlike subroutines and gate scopes, this includes variables
that are not <code class="docutils literal notranslate"><span class="pre">const</span></code>.  This is broadly similar how these constructs behave in
other procedural languages, such as C.</p>
<p>The iteration variable of a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop has lifetime and visibility as if it
were declared as the first statement in the body of that loop.  It is not
accessible after the body of the loop.</p>
<p>The blocks associated with <code class="docutils literal notranslate"><span class="pre">if</span></code> and its corresponding <code class="docutils literal notranslate"><span class="pre">else</span></code> define two
different scopes; the variables and definitions are not shared between them.</p>
<p>As with subroutine scopes, variables defined locally in these scopes (including
the for-loop iteration variable) may shadow variables with the same name in
outer scopes.  When the defining scope of a shadowing variable ends, the
previous variable (which was shadowed) becomes accessible again.  Qubits and
arrays cannot be declared within local block scopes, but aliases can.</p>
<p>Some further examples:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">OPENQASM</span><span class="w"> </span><span class="mf">3.0</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">         </span><span class="c1">// &#39;ii&#39; is declared in the global scope.</span>
<span class="linenos"> 4</span><span class="n">qubit</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w">           </span><span class="c1">// &#39;q&#39; is declared in the global scope.</span>
<span class="linenos"> 5</span><span class="n">let</span><span class="w"> </span><span class="n">some_q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span><span class="w">  </span><span class="c1">// alias &#39;some_q&#39; is declared in the global scope.</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 8</span><span class="w">  </span><span class="n">ii</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">    </span><span class="c1">// This is the global &#39;ii&#39;, which now has the value 200.</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w">  </span><span class="c1">// A local variable &#39;ii&#39; is declared, which shadows the global definition.</span>
<span class="linenos">11</span><span class="w">  </span><span class="c1">// The global &#39;ii&#39; is no longer accessible until this scope ends.</span>
<span class="linenos">12</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">13</span><span class="w">  </span><span class="c1">// The local variable &#39;ii&#39; is modified, and now has the value 2.</span>
<span class="linenos">14</span><span class="w">  </span><span class="n">ii</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="linenos">15</span><span class="p">}</span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="c1">// The local &#39;ii&#39; went out of scope at the conclusion of the &#39;if&#39; block, and</span>
<span class="linenos">18</span><span class="c1">// the previous &#39;ii&#39; defined on line 3 is accessible again.</span>
<span class="linenos">19</span><span class="n">ii</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// global &#39;ii&#39; is now 400.</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="n">uint</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">22</span><span class="k">for</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">23</span><span class="w">  </span><span class="c1">// The global &#39;ii&#39; is shadowed by the iteration variable &#39;ii&#39;, which also</span>
<span class="linenos">24</span><span class="w">  </span><span class="c1">// has a different type.  The outer &#39;sum&#39; is still accessible.</span>
<span class="linenos">25</span>
<span class="linenos">26</span><span class="w">  </span><span class="c1">// Values at this point in various iterations:</span>
<span class="linenos">27</span><span class="w">  </span><span class="c1">//  Iteration   ii    sum</span>
<span class="linenos">28</span><span class="w">  </span><span class="c1">//     0        1     0</span>
<span class="linenos">29</span><span class="w">  </span><span class="c1">//     1        2     2</span>
<span class="linenos">30</span><span class="w">  </span><span class="c1">//     2        3     6</span>
<span class="linenos">31</span><span class="w">  </span><span class="c1">//     3        4     12</span>
<span class="linenos">32</span>
<span class="linenos">33</span><span class="w">  </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ii</span><span class="p">;</span><span class="w">  </span><span class="c1">// Iteration variable &#39;ii&#39; is added to global &#39;sum&#39;</span>
<span class="linenos">34</span>
<span class="linenos">35</span><span class="w">  </span><span class="c1">//  Iteration   ii    sum</span>
<span class="linenos">36</span><span class="w">  </span><span class="c1">//     0        1     1</span>
<span class="linenos">37</span><span class="w">  </span><span class="c1">//     1        2     4</span>
<span class="linenos">38</span><span class="w">  </span><span class="c1">//     2        3     9</span>
<span class="linenos">39</span><span class="w">  </span><span class="c1">//     3        4     16</span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">42</span><span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// For-loop iteration variable shadowed.</span>
<span class="linenos">43</span><span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">uint</span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span>
<span class="linenos">44</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">45</span><span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ii</span><span class="p">;</span><span class="w">      </span><span class="c1">// &#39;ii&#39; is the for-loop iteration variable.</span>
<span class="linenos">46</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="w">  </span><span class="c1">//  Iteration   ii    sum</span>
<span class="linenos">49</span><span class="w">  </span><span class="c1">//     0        1     2</span>
<span class="linenos">50</span><span class="w">  </span><span class="c1">//     1        2     6</span>
<span class="linenos">51</span><span class="w">  </span><span class="c1">//     2        3     12</span>
<span class="linenos">52</span><span class="w">  </span><span class="c1">//     3        4     36</span>
<span class="linenos">53</span>
<span class="linenos">54</span><span class="w">  </span><span class="n">U</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">55</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pi</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w">  </span><span class="c1">// Global-scope qubit &#39;q&#39; is in scope here.</span>
<span class="linenos">55</span><span class="p">}</span>
<span class="linenos">56</span>
<span class="linenos">57</span><span class="c1">// The lifetime of the local for-loop iteration variable &#39;ii&#39; ended at the</span>
<span class="linenos">58</span><span class="c1">// conclusion of the for-loop body, and the global &#39;ii&#39; is back in scope.</span>
<span class="linenos">59</span>
<span class="linenos">60</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">61</span><span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">some_q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">4</span><span class="p">];</span><span class="w">  </span><span class="c1">// local alias &#39;some_q&#39; shadows the global alias.</span>
<span class="linenos">62</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">OpenQASM Live Specification</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="comments.html">Comments</a></li>
<li class="toctree-l2"><a class="reference internal" href="comments.html#version-string">Version string</a></li>
<li class="toctree-l2"><a class="reference internal" href="comments.html#included-files">Included files</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types and Casting</a></li>
<li class="toctree-l2"><a class="reference internal" href="gates.html">Gates</a></li>
<li class="toctree-l2"><a class="reference internal" href="insts.html">Built-in quantum instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="classical.html">Classical instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="subroutines.html">Subroutines</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Scoping of variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#global-scope">Global scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subroutine-and-gate-scope">Subroutine and gate scope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-scope">Block scope</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="directives.html">Directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="directives.html#input-output">Input/output</a></li>
<li class="toctree-l2"><a class="reference internal" href="delays.html">Circuit timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pulses.html">Pulse-level descriptions of gates and measurement</a></li>
<li class="toctree-l2"><a class="reference internal" href="openpulse.html">OpenPulse Grammar</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../grammar/index.html">OpenQasm 3.0 Grammar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Language</a><ul>
      <li>Previous: <a href="subroutines.html" title="previous chapter">Subroutines</a></li>
      <li>Next: <a href="directives.html" title="next chapter">Directives</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017-2020, Andrew W. Cross, Lev S. Bishop, John A. Smolin, Jay M. Gambetta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/language/scope.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>